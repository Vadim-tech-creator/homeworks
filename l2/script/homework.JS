// undefined + 1; // тут джс намагається перетворити undefined на число, але це неможливо  і він перетворюється на NaN, а при додаванні будь якого числа до NaN дає NaN
// 'true' == true // результат false так як оператор == перевіряє рівність двох значень, а в цьому випадку опернати мають різні типи(рядок, число)
// false == 'false' анологічна ситуація як і в минулому прикладі
// null == '' // результат false так як null це неіснуюче значення а "" це порожній рядок тому їх порівняти неможливо
// 3 ** (9 / 3); // спочатку відбувається дія в лапках а потім піднесення до степеню результат 27
// !!'false' == !!'true' // тут подвійне не перетворює false на true так як будя-який ненульовий рядок є істинним і подвійне ні перетворює на true результат true
// 0 || '0' && 1 // спочатку виконуємо && він шукає перший фолс якщ оні то повертає останнє значення тобто 1, оператор || шукає перший true 0 це false значення тому результат 1
// 1 < 2 < 3 // результат true так як всі порівняння рівні
// 'foo'+ + +'bar' // оператор + перед bar намагається перетворити його у число,  але bar це не число и тому він стає NaN, а потім відбувається конкатенація і тому результат fooNaN
// 3 ** 2 / 3; // спочатку підносимо до степеня а потім ділення результат 3
// 1 < 2 > 3 // результат false так як 2 порівняння не є вірним
// (+null == false) < 1; // у () null перетворюється на 0 а отже їх можна піднести до спільного типу результатом якого буде true а при порвінянні так як true це 1  вийде такий вираз 1>1 результат false
// false && true || true // спочатку && де результат false потім || результат true
// false && (true || true); // спочатку дія у () результат якої true потім || результат false
// (+null == false) < 1 ** 5; // у () null перетворюється на 0 а отже їх можна піднести до спільного типу результатом якого буде true а при порвінянні так як true це 1  вийде такий вираз 1>1**5 все одно 1>1 результат false
